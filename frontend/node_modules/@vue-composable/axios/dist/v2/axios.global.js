var vueComposableAxios = (function (exports, axios, compositionApi) {
    'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e['default'] : e; }

    var axios__default = /*#__PURE__*/_interopDefaultLegacy(axios);

    const isString = (val) => typeof val === "string";
    const isBoolean = (val) => typeof val === "boolean";
    const isObject = (val) => val !== null && typeof val === "object";

    function usePromise(fn, lazyOptions) {
        if (!fn) {
            throw new Error(`[usePromise] argument can't be '${fn}'`);
        }
        if (typeof fn !== "function") {
            throw new Error(`[usePromise] expects function, but received ${typeof fn}`);
        }
        const [lazy, throwException] = isBoolean(lazyOptions)
            ? [lazyOptions, false]
            : isObject(lazyOptions)
                ? [lazyOptions.lazy, lazyOptions.throwException]
                : [false, false];
        const loading = compositionApi.ref(false);
        const error = compositionApi.ref(null);
        const result = compositionApi.ref(null);
        const promise = compositionApi.ref();
        const exec = async (...args) => {
            loading.value = true;
            error.value = null;
            const throwExp = args &&
                fn.length !== args.length &&
                args.length > 0 &&
                isBoolean(args[args.length - 1])
                ? args[args.length - 1]
                : throwException;
            const currentPromise = (promise.value = fn(...args));
            try {
                const r = await currentPromise;
                if (promise.value === currentPromise) {
                    result.value = r;
                }
                return r;
            }
            catch (er) {
                if (compositionApi.toRaw(promise.value) === compositionApi.toRaw(currentPromise)) {
                    error.value = er;
                    result.value = null;
                }
                return throwExp ? currentPromise : undefined;
            }
            finally {
                if (promise.value === currentPromise) {
                    loading.value = false;
                }
            }
        };
        if (!lazy) {
            // @ts-ignore
            exec();
        }
        return {
            exec,
            result,
            promise,
            loading,
            error,
        };
    }

    function makeAxios(client, throwException = false) {
        const isCancelled = compositionApi.ref(false);
        const cancelledMessage = compositionApi.ref(null);
        let cancelToken = undefined;
        const cancel = (message) => {
            if (!cancelToken) {
                /* istanbul ignore else */
                {
                    throw new Error("Cannot cancel because no request has been made");
                }
            }
            cancelToken.cancel(message);
            isCancelled.value = true;
            cancelledMessage.value = message;
        };
        const use = usePromise(async (request) => {
            cancelToken = axios__default.CancelToken.source();
            isCancelled.value = false;
            cancelledMessage.value = null;
            const opts = isString(request) ? { url: request } : request;
            return client.request({
                cancelToken: cancelToken.token,
                ...opts
            });
        }, {
            lazy: true,
            throwException
        });
        const data = compositionApi.computed(() => (use.result.value && use.result.value.data) ||
            (use.error.value &&
                use.error.value.response &&
                use.error.value.response.data) ||
            null);
        const status = compositionApi.computed(() => (use.result.value && use.result.value.status) ||
            (use.error.value &&
                use.error.value.response &&
                use.error.value.response.status) ||
            null);
        const statusText = compositionApi.computed(() => (use.result.value && use.result.value.statusText) ||
            (use.error.value &&
                use.error.value.response &&
                use.error.value.response.statusText) ||
            null);
        return {
            ...use,
            client,
            data,
            status,
            statusText,
            cancel,
            isCancelled,
            cancelledMessage
        };
    }

    function useAxios(configUrlThrowException, configThrowException, throwException = false) {
        /* istanbul ignore next  */
        !axios__default && console.warn(`[axios] not installed, please install it`);
        const config = !isString(configUrlThrowException) && !isBoolean(configUrlThrowException)
            ? configUrlThrowException
            : isObject(configThrowException)
                ? configThrowException
                : undefined;
        throwException = isBoolean(configUrlThrowException)
            ? configUrlThrowException
            : isBoolean(configThrowException)
                ? configThrowException
                : throwException;
        const axiosClient = axios__default.create(config);
        const use = makeAxios(axiosClient, throwException);
        // if url provided in the config, execute it straight away
        // NOTE: `false` is passed to the `exec` to prevent the exception to be thrown
        if (typeof configUrlThrowException === "string") {
            use.exec({ ...config, url: configUrlThrowException }, false);
        }
        else if (config && config.url) {
            use.exec(config, false);
        }
        return use;
    }

    exports.makeAxios = makeAxios;
    exports.useAxios = useAxios;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

}({}, axios, vueCompositionApi));
